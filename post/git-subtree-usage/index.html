<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Git Subtree 简单使用 - zlog - zyk's blog</title>
<meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Yike Zhou"><meta name=description content="git subtree 命令的使用方法"><meta name=keywords content="Git"><meta name=generator content="Hugo 0.120.4 with theme even"><link rel=canonical href=https://yikezhou.github.io/zlog/post/git-subtree-usage/><link rel=apple-touch-icon sizes=180x180 href=/zlog/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/zlog/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/zlog/favicon-16x16.png><link rel=manifest href=/zlog/manifest.json><link rel=mask-icon href=/zlog/safari-pinned-tab.svg color=#5bbad5><link href=/zlog/sass/main.min.b874a8796a492f0d7c86bb24c33cbf052935783a5778ebaf819a8e514bf49f10.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>zlog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/zlog/><li class=mobile-menu-item>Home</li></a><a href=/zlog/post/><li class=mobile-menu-item>Archives</li></a><a href=/zlog/tags/><li class=mobile-menu-item>Tags</li></a><a href=/zlog/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>zlog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/zlog/>Home</a></li><li class=menu-item><a class=menu-item-link href=/zlog/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/zlog/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/zlog/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Git Subtree 简单使用</h1><div class=post-meta><span class=post-time>2022-09-07</span><div class=post-category><a href=/zlog/categories/%E7%BC%96%E7%A8%8B/>编程</a></div><span class=more-meta>约 2041 字 </span><span class=more-meta>预计阅读 5 分钟</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#初次使用>初次使用</a></li><li><a href=#更多命令>更多命令</a><ul><li><a href=#添加一个-subtree>添加一个 subtree</a></li><li><a href=#拉取远程仓库的更新>拉取远程仓库的更新</a></li><li><a href=#在-my-repo-中修改子模块>在 my-repo 中修改子模块</a></li><li><a href=#精简提交历史>精简提交历史</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=post-outdated><div class=warn><p>【注意】最后更新于 <span class=timeago datetime=2022-12-09T12:00:00 title="December 9, 2022">December 9, 2022</span>，文中内容可能已过时，请谨慎使用。</p></div></div><div class=post-content><div class="admonition info"><p class=admonition-title>不那么好用的 Git 子模块 (submodule)</p><p>在 <em>Pro Git</em> 这本书中，子模块的功能被概括为：</p><p>“子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。”</p><p>当使用了一段时间子模块之后，你可能会发现它有这样一些不便之处：</p><ol><li>在克隆主项目到本地后，子模块并不会直接出现在它的目录下，需要手动将其克隆到本地。</li><li>如果主项目中不同的分支 (branch) 包含不同版本的子模块，切换分支后，需要手动同步子模块的内容。</li><li>必须时常留意其他人是否修改了子模块，避免你的 commit 中子模块的版本不对。</li><li>如果想在子模块上做一些修改，然后 push 到它的远程仓库，也需要万分小心，确保远程的子模块和主项目都得到了更新。</li></ol><p>其中，一部分问题可以通过配置 <code>git config submodule.recurse true</code> 来解决。但是，子模块的操作还是比较繁琐。</p></div><p>总之，对于作者这样的 Git 新手，子模块的使用实在是太令人头大了。所以，我发现了 subtree 之后，立刻抛弃了 submodule。</p><p>subtree 与 submodule 相比，不会创建新的 metadata 文件（.gitmodule 等），而且其它的 git repo 使用者不会发现使用 subtree 的痕迹。
git clone 的时候，所有的依赖都会一起被 clone 下来。所以用它来管理一个项目的依赖非常地方便。</p><figure class=center><img src=https://www.repstatic.it/content/localirep/img/rep-torino/2016/10/07/112008349-c2daced1-20ee-487c-98a2-ffa26fc2b400.jpg alt=granadoubletree.jpg><figcaption><h4>double tree of Casorzo</h4></figcaption></figure><h1 id=初次使用>初次使用</h1><p>一开始，我只学了下面3个简单粗暴的命令：</p><ul><li>添加：把远程仓库 <code>{remote repo URL}</code> 的某个分支 <code>{remote branch}</code> 添加到指定目录 <code>{local directory}</code> 下，并自动创建一个提交。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree add --prefix <span class=o>{</span><span class=nb>local</span> directory<span class=o>}</span> <span class=o>{</span>remote repo URL<span class=o>}</span> <span class=o>{</span>remote branch<span class=o>}</span> --squash
</span></span></code></pre></td></tr></table></div></div><ul><li>拉取更新：将 <code>add</code> 换成 <code>pull</code> 即可。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree pull --prefix <span class=o>{</span><span class=nb>local</span> directory<span class=o>}</span> <span class=o>{</span>remote repo URL<span class=o>}</span> <span class=o>{</span>remote branch<span class=o>}</span> --squash
</span></span></code></pre></td></tr></table></div></div><ul><li>发布更新：使用 <code>push</code> 命令即可。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git subtree push --prefix <span class=o>{</span><span class=nb>local</span> directory<span class=o>}</span> <span class=o>{</span>remote repo URL<span class=o>}</span> <span class=o>{</span>remote branch<span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这样用了一段时间之后，突然发现 <code>pull</code> 命令不好用了，竟然提示有冲突！好不容易合并之后，发现提交历史变得非常诡异。一番查找资料后，我发现，subtree 原来只是 Git 提供的一个脚本，它其实是调用了一组 Git 的命令完成的。我们也可以手动执行这些命令（主要是 <code>merge</code>、<code>cherry-pick</code> 和 <code>read-tree</code>）。</p><div class="admonition quote"><p class=admonition-title>底层命令与上层命令</p><p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的子命令。这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。</p></div><h1 id=更多命令>更多命令</h1><p>现在，我有了一个更复杂的需求：</p><ol><li>自己的仓库 my-repo 依赖 GitHub 上一个开源的仓库 that-repo；</li><li>自己在本地对开源工具进行修改；</li><li>同时需要拉取远程仓库的更新到本地。</li></ol><div class="admonition tip"><p class=admonition-title>提示</p><p>在测试时，可以在本地创建2个目录，模拟本地仓库和远程仓库。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── my-repo
</span></span><span class=line><span class=cl>└── remotes
</span></span><span class=line><span class=cl>    └── that-repo
</span></span></code></pre></td></tr></table></div></div></div><h2 id=添加一个-subtree>添加一个 subtree</h2><p>上一节中用到的 <code>git subtree</code> 是 Git 提供的一个捷径。这里我们使用手动添加的方法，看看需要进行哪些操作。</p><p>首先，可以将子项目的 URL 记录为一个 remote repo，避免每次都重复输入长长的地址。在 <code>my-repo</code> 目录下执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote add -f that-repo ../remotes/that-repo
</span></span></code></pre></td></tr></table></div></div><p>其中 <code>-f</code> 表示同时对它执行 <code>fetch</code> 命令，所以也可以这样写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote add that-repo ../remotes/that-repo
</span></span><span class=line><span class=cl>$ git fetch that-repo
</span></span></code></pre></td></tr></table></div></div><p>下一步，需要将 that-repo 中的内容放入 my-repo 的一个子目录 <code>that-repo/</code> 中，作为一个 subtree。这一步实际上得进行2个操作：</p><ol><li>向 <code>./my-repo/that-repo</code> 中添加来自 that-repo 的文件。</li><li>修改 my-repo 仓库的 index（保存暂存区信息的文件）。</li></ol><p>首先使用 <code>git merge</code>，其中 <code>-s ours</code> 指定了合并的策略。
接着使用 <a href=https://git-scm.com/docs/git-read-tree><code>git read-tree</code></a> 命令，它会读取一个分支的根目录树到当前的暂存区和工作目录里：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git merge -s ours --no-commit --allow-unrelated-histories that-repo/main
</span></span><span class=line><span class=cl>$ git read-tree --prefix<span class=o>=</span>that-repo -u that-repo/main
</span></span></code></pre></td></tr></table></div></div><p>完成后，执行 <code>git status</code> 命令可以观察到 my-repo 仓库中出现了来自 that-repo 的新文件。我们可以提交这一更改到 my-repo。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git commit -m <span class=s1>&#39;add that-repo as subtree&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>这样做有一个缺点，就是会将 that-repo 的所有分支提交历史都添加到 my-repo 的历史中。</p><h2 id=拉取远程仓库的更新>拉取远程仓库的更新</h2><p>现在 that-repo 远程仓库更新了，my-repo 也新增了一些不相关的提交（没有修改 that-repo），我们需要更新本地仓库 my-repo 中的版本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git fetch that-repo
</span></span><span class=line><span class=cl>$ git merge -s subtree that-repo/main
</span></span></code></pre></td></tr></table></div></div><p><code>-s subtree</code> 将合并策略设置为“子树合并”，这样做将把 that-repo 中新增的修改添加到 my-repo 中。</p><p>也可以用一行命令完成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git pull -s subtree that-repo main
</span></span></code></pre></td></tr></table></div></div><p>如果在 my-repo 中已经对 that-repo 进行了修改，前一种方法可以正常工作，后一种可能会报错 <code>fatal: Need to specify how to reconcile divergent branches.</code>——这个问题 Google 一下可以找到很多解释，这里不再赘述。</p><h2 id=在-my-repo-中修改子模块>在 my-repo 中修改子模块</h2><p>当你想对 that-repo 进行的修改和 my-repo 有关，并且这个修改不需要 push 到远程的 that-repo 上时，subtree 就比 submodule 好用多了。</p><p>将 my-repo 中的提交分为下面4种：</p><ol><li>仅对 that-repo 进行了修改，并且需要推送到远程 that-repo 仓库（例如 bug-fix）。</li><li>在 my-repo 上进行的修改，与 that-repo 无关。</li><li>对 my-repo 和 that-repo 都进行了修改，也需要推送到 that-repo 仓库。</li><li>对 that-repo 的修改，不需要同步到远程 that-repo 仓库。</li></ol><p>如果只使用 <code>git subtree</code> 操作，则不能保留一部分不需要推送的修改。这个需求要用到 <code>git cherry-pick</code> 命令，并且最好用另一个分支维护 <code>that-repo</code>。
首先创建一个新的分支：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout -b backport-that-repo that-repo/main
</span></span></code></pre></td></tr></table></div></div><p>下面的两条指令分别将第1种和第3种提交应用到 <code>backport-that-repo</code> 分支上，修改完成后，可以直接在这一分支上调用 <code>git push</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git cherry-pick -x &lt;commit&gt;
</span></span><span class=line><span class=cl>$ git cherry-pick -x --strategy<span class=o>=</span>subtree &lt;commit&gt;
</span></span></code></pre></td></tr></table></div></div><h2 id=精简提交历史>精简提交历史</h2><p>有时候，我们不需要在 my-repo 中保留 that-repo 全部的分支提交历史，这时可以使用 <code>--squash</code> 选项。</p><h1 id=参考资料>参考资料</h1><ul><li><a href=https://gist.github.com/SKempin/b7857a6ff6bddb05717cc17a44091202>Git Subtree Basics</a></li><li><a href="https://docs.github.com/en/get-started/using-git/about-git-subtree-merges?platform=linux">About Git subtree merges</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Git subtree: the alternative to Git submodule</a></li><li><a href=https://medium.com/@porteneuve/mastering-git-subtrees-943d29a798ec>Mastering Git subtrees</a></li><li><a href=https://git-scm.com/book/zh/v2>Pro Git book</a></li><li><a href=https://git-scm.com/docs/git-read-tree>git-read-tree - Reads tree information into the index</a></li><li><a href=https://juejin.cn/post/6881580754854215687>Git subtree用法与常见问题分析</a></li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Yike Zhou</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-12-09</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/><img alt=知识共享许可协议 style=border-width:0 src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png></a>&nbsp;<a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/zlog/tags/git/>Git</a></div><nav class=post-nav><a class=prev href=/zlog/post/intro-to-formal-verification-with-yosys/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">基于 Yosys 的形式化验证入门</span>
<span class="prev-text nav-mobile">上一篇</span>
</a><a class=next href=/zlog/post/useful-pacman-commands/><span class="next-text nav-default">Pacman 常用命令</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://github.com/YikeZhou class="iconfont icon-github" title=github></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span><span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a>
</span><span class=copyright-year>&copy;
2020 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>Yike Zhou</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script><script>var languageCode="en".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/zlog/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>